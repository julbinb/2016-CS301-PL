
<!-- Модуль 2
	 (2::3) Лекция 9. Типобезопасность SNB -->

#### Замечания к контрольной ####

1.	Доказать, что из `a <= b` следует `succ(a) <= succ(b)`.

2.	Доказать детерминированность отношения вычисления на примере правила
	`E-AddRight` (`t1 + t2 -> t1 + t2'` при условии `t2 -> t2'`).

#### Замечания к семинару ####

Якобы неопределённость отношения типизации проявляется в том, что
какую предпосылку проверять первой.

А в случае недерминированного отношения вычисления нужно ещё и правило 
для применения выбрать.

#### Что такое тип ####

* Значение это нечто, что можно оценивать, хранить, использовать в структуре данных,
передавать в качестве аргумента или возвращать в качестве результата.

* Что такое тип?

* Реалист: Тип это набор значений. 

* Идеалист: Нет. Тип это абстрактная сущность, значения которой можно воспринять 
только через некую призму типа. 

* Начинающий программист: Разве тип это не имя для набора значения?

* Средний программист: Нет. Тип это способ классификации значений по их
свойствам и поведению.

* Опытный программист: Нет. Тип это набор значений и операций.

* Алгебраист: Ага! Значит тип это алгебра, набор значений и операций,
определённых на этих значениях.

* Тайпчекер: Типы более практичны, это ограничения на выражения, которые
гарантируют совместимость между операторами и операндами.

* Система вывод типов: Да, и более того, поскольку система типов это набор
правил, сопоставляющих каждое выражение типу, тип отражает набор всех 
осмысленных контекстов, в которых может возникнуть выражение.

* Система верификации: Давайте говорить просто, типы это инварианты поведения,
которым должны удовлетворять инстанции типа.

* Разработчик ПО: Для меня важно, что типы это инструмент управления
разработкой и изменением ПО.

* Компилятор: Все эти разговоры сбивают меня с толку, типы определяют 
требования к хранению переменных типа.

Original:

* A value is any thing that may be evaluated, stored, incorporated in a data struc-
ture, passed as an argument or returned as a result.

* What is a type?

* Realist: A type is a set of values.

* Idealist: No. A type is a conceptual entity whose values are accessible only
through the interpretive filter of type. 

* Beginning Programmer: Isn’t a type a name for a set of values?

* Intermediate Programmer: No. A type is a way to classify values by their
properties and behavior.

* Advanced Programmer: No. A type is a set of values and operations.

* Algebraist: Ah! So a type is an algebra, a set of values and operations defined
on the values.

* Type checker: Types are more practical than that, they are constraints on
expressions to ensure compatibility between operators and their operand(s).

* Type Inference System: Yes and more, since a type system is a set of rules
for associating with every expression a unique and most general type that
reflects the set of all meaningful contexts in which the expression may
occur.

* Program verifier: Lets keep it simple, types are the behavioral invariants that
instances of the type must satisfy.

* Software engineer: What is important to me is that types are a tool for man-
aging software development and evolution.

* Compiler: All this talk confuses me, types specify the storage requirements for
variables of the type.


#### Замечания к прошлой лекции ####

* 	В Haskell есть поддержка динамической типизации — специальный тип 
	данных [`Data.Dynamic`](http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Dynamic.html).

* 	Единственность типа в случае T-If (для `t2`, `t3` воспользоваться
	предположением индукции).

**Теорема.** Если терм `t` корректно типизирован, то все его подтермы
также корректно типизированы.  
_Доказательство._ Индукция по `t`.

* `succ(t1) : T` Есть только одно правило T-Succ, то есть `T = Nat` 
  и `t1 : Nat`.
  

## Безопасность ##

**Продвижение.** Правильно типизированный терм не может быть тупиковым 
(это либо значение, либо можно проделать шаг вычисления).  
**Сохранение.** Если для правильно типизированного терма можно проделать
шаг вычисления, то полученный терм тоже правильно типизирован.

#### Продвижение ###

Пусть `t` — правильно типизированный терм, то есть существует тип `T`,
такой что `t : T`. Тогда либо `t` — это значение, либо существует
некоторый терм `t'`, такой что `t -> t'`.

_Доказательство_ конечно-же по индукции. По дереву вывода
отношения типизации `t : T`.

* 	T-True, T-False и T-Zero — терм является значением.

*	T-If. `t = if t1 then t2 else t3 : T`
	Так как терм тпизирован, мы знаем, что `t1 : Bool`, а `t2 : T` и `t3 : T`.
	
	Все подтермы правильно типизированы, для всех подтермов выполняется 
	предположение индукции. Если `t1` это значение, то либо `t1 = true`, 
	либо `t1 = false`. То вычисляется по правилу `E-IfTrue`/`E-IfFalse`.  
	Иначе существует `t1'`, такой что `t1 -> t1'`. 
	Тогда по правилу E-If переходим к `if t1' then t2 else t3`.
	
*	T-Succ. `t = succ(t1) : Nat`. 
	
	`t1` либо значение типа `Nat`, то есть числовое значение. Тогда
	`succ(t1)` тоже значение.   
	Либо можно проделать шаг `t1 -> t1'` и тогда вычисляем по E-Succ.
	 
#### Сохранение ####

Если `t : T` и существует `t'`, `t -> t'`, то `t' : T`.

**Замечание.** Здесь полученный (редуцированный) терм не просто типизируем,
а даже имеет тот же тип.

_Доказательство_ по индукции по дереву вывода `t : T`.

*	T-True. `t = true : Bool`. Терм `true` является значением, поэтому
	второе предположение о `t'` не выполянется и теорема не применима.
	
*	T-If. `t = if t1 then t2 else t3 : T`. Знаем, что `t1 : Bool`,
	`t2 : T`, `t3 : T` и теорема выполняется для всех подтермов.
	
	Если `t1 = true`, то по правилу `E-IfTrue` вычисляем терм, получаем
	`t2 : T`.
	
	Если `t1 -> t1'`, то выполняется предположение индукции и `t1' : Bool`.
	Тогда `if t1' then t2 else t3 : T`.
	

## Задания ##

1. 	Подтермы типизированного типизированы для `if` и `true`.
2.	Единственность типа для `iszero`.
3.	Продвижение для T-Pred и T-IsZero.
4.	Сохранение для T-Pred и T-Zero.
5.	Сохранение вторым способом для `E-PredZero`, `E-PresSucc`, `E-Pred`, `E-Succ`.


## Литература ##

*	Бенджамин Пирс, глава 8 (типизированные арифметические выражения).
