
<!-- Модуль 2
	 (2::2) Лекция 8. Типизация SNB -->

## Статика и динамика ##

Программы пишут для того, чтобы их _выполнять_.
Выполнение — это **динамический** этап обработки программы.
На этапе выполнения может произойти _ошибка_.

Представьте, что случилось ужасное, вам вшили чипы и запрограммировали.
Вы все — это элементы программы туристического похода. 
В какой-то момент подходите к глубокому
ущелью, через которое переброшен верёвочный мост. Нужно перейти,
некоторые боятся переходить в одиночку, вы разбиваетесь на группы.  
На мосту висит табличка, что мост может выдержать только ограниченное 
число человек, например, 3. Что делать?

* 	То, что мы делали раньше в языке SNBU: группа отправляется на мост.
	Или всё ок, группа переходит на другую сторону.  
	Или мост обрывается и... произошла _ошибка времени выполнения_!
	
*	А что надо было сделать вместо этого? Посчитать количество человек
	в группе. Если в группе больше 3-х человек, можно предсказать,
	что произойдёт ошибка. Программа плохая.
	
То есть нужно было **статически**, до выполнения программы сделать 
какие-то проверки.

Смотрите, правила игры известны: мост выдерживает не более трёх человек.
А в языке SNBU оператор `pred` применяется только к натуральным числам.

Можно ничего не проверять и столкнуться с ошибкой времени выполнения.
А можно проверить и избежать ошибки.

Что можно _проверять статически_? Challenge: назовите проверки, в которых
не участвуют типы.

* неинициализрованные переменные;
* деление на ноль;
* выход за границы массива;
* указатели;
* мёртвый код;
* дублирование кода;
* etc.

Неплохо, есть кое-какие статические проверки. Но огромная часть
**статического анализа**, конечно, связана с **типами**. То есть
это проверки того, что в том или ином месте используются термы
допустимого вида, типа. 

Мост не берёт больше 3-х человек. Значит группы должны быть не более,
чем по три человека.

Ну что, вы готовы написать свою первую в жизни систему типов?!

## Типизированный язык SNB (Simple Nat Bool) ##

А что такое система типов?

*	Википедия: это некий набор правил, которые позволяют приписывать
	конструкциям языка типы.

*	Пирс: гибко управляемый синтаксический метод доказательства  
	отсутствия в программе определённых видов поведения при помощи 
	_классификации выражений_ языка по разновидностям вычисляемых ими значений.

**Часто говорят, что система типов** — это легковесный (облегчённый)
_формальный метод_, который позволяет проверить некоторые свойства _программы_.

Определение системы типов включает несколько элементов. Нужно определить:

* 	какие **типы** есть в языке (то есть на какие классы можно разделить
	термы языка);
*	как понять, к какому типу относится то или иное значение (то есть
	**правила типизации**).
	
Нотация:

*	типы будем обозначать большими латинскими буквами `T`, `S`, `U`;
*	утверждение «терм `t` имеет тип `T`» будем записывать как `t : T`.
	Отношение `t : T` будем называть **отношением типизации**.  
	Это бинарное отношение на термах и типах.
	
### Типы языка SNB ###

<pre>
T ::=
		Bool
		Nat
</pre>

### Отношение типизации ###

Как мы обычно определяем отношения? Правильно, _индуктивно_!

$$\cfrac{}{\mathtt{true} : \mathtt{Bool}}\,(\text{T-True}) \qquad
\cfrac{}{\mathtt{false} : \mathtt{Bool}}\,(\text{T-False})$$

$$\cfrac{}{\mathtt{zero} : \mathtt{Nat}}\,(\text{T-Zero})$$

$$\cfrac{t_1 : \mathtt{Nat}}{\mathtt{succ}(t_1) : \mathtt{Nat}}\,(\text{T-Succ}) \qquad
\cfrac{t_1 : \mathtt{Nat}}{\mathtt{pred}(t_1) : \mathtt{Nat}}\,(\text{T-Pred})$$

$$\cfrac{t_1 : \mathtt{Nat}}{\mathtt{iszero}(t_1) : \mathtt{Bool}}\,(\text{T-IsZero})$$

$$\cfrac{t_1 : \mathtt{Bool} \quad t_2 : \mathtt{T} \quad t_3 : \mathtt{T}}
{\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 : \mathtt{T}}\,(\text{T-If})$$

_Замечание._ Наш анализ типов _консервативен_ (conservative), он 
учитывает только информацию, доступную статически. Именно поэтому в 
правиле T-If мы требуем, чтобы обе ветви имели один тип. Таким образом мы
отвергаем ряд хороших программ, но иначе мы просто не знаем, как типизировать.

Такие правила типизации называются _синтаксически управляемыми_ 
(syntax-directed или ещё syntax-driven). Так как по синтаксической форме  
терма однозначно понятно, какое правило применять.

Определение. Терм `t` называют **типизируемым** (typable) или
**корректно (правильно) типизированным** (well-typed), если существует тип `T`,
такой что `t : T`.  
Некорректно типизированным (ill-typed), если не существует такого `T`.

_Задание._ Привести дерево вывода типизации для 
`pred(if iszero(0) then succ(0) else pred(0))`.

**Теорема.** Если терм `t` корректно типизирован, то все его подтермы
также корректно типизированы.  
_Доказательство._ Индукция по `t`.

* `succ(t1) : T` Есть только одно правило T-Succ, то есть `T = Nat` 
  и `t1 : Nat`.
  
Остальные случаи аналогично. Домой `if` и `true`.

**Теорема.** Если терм типизируем, то у него есть единственный тип.  
_Доказательство._ Индукция по `t`.

* `succ(t1) : T` и `succ(t1) : T'`. Это может быть только `Nat`, совпадает.
* `if t1 then t2 else t3 : T` и `if t1 then t2 else t3 : T'`.
  Здесь уже индуктивной гипотезой нужно воспользоваться.

#### Безопасность ####

Напомните, для чего мы определяли систему типов? Чтобы избавиться
от ошибок времени выполнения. А у нас это получилось?

Вроде бы да, но это нужно доказать. То есть нужно доказать, что
_правильно типизированные термы никогда не «ломаются»_, то есть не заходят
в тупик в случае языка SNB. 
Это _свойство_ системы типов называется **безопасностью** (safety) 
или корректностью (soundness).

Существует два основных подхода к доказательству типобезопасности:

* через теоремы о сохранении и продвижении;
* через логические отношения (logical relations).

Мы будем использовать метод доказательства через 
**сохранение и продвижение** (progress and preservation).

Что хотим доказать: если `t : T`, то в процессе вычисления `t` 
мы _гарантированно_ дойдём до значения `t ->* v`.

**Продвижение.** Правильно типизированный терм не может быть тупиковым 
(это либо значение, либо можно проделать шаг вычисления).  
**Сохранение.** Если для правильно типизированного терма можно проделать
шаг вычисления, то полученный терм тоже правильно типизирован.


## Задания ##

1. 	Подтермы типизированного типизированы для `if` и `true`.
2.	Единственность типа для `iszero`.
3.	Продвижение для T-Pred и T-IsZero.
4.	Сохранение для T-Pred и T-Zero.
5.	Сохранение вторым способом для `E-PredZero`, `E-PresSucc`, `E-Pred`, `E-Succ`.


## Литература ##

*	Бенджамин Пирс, глава 8 (типизированные арифметические выражения).
