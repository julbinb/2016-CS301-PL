## Необходимый аппарат ##

### Множества и отношения ###

**Множество (set)** — набор различных _объектов_. Множество может быть конечным и бесконечным.  
**Примеры.** $L = \{a, b, c\}$, $E = \{ n \in \mathbb{N} \ | \ \exists p \in \mathbb{N}.n = 2p \}$ .

_N_-местное **отношение (relation)** — множество
$R \subseteq S_1 \times S_2 \times \ldots \times S_n$ кортежей.  
Если $s_1 \in S_1, \, \ldots, \, s_n \in S_n$ и $(s_1, s_2, \, \ldots \, s_n) \in R$,
то говорят, что $s_1, s_2, \, \ldots \, s_n$ **связаны (related)** отношением $R$.

_N_-местное отношение $R \subseteq S_1 \times S_2 \times \ldots \times S_n$ можно назвать **предикатом (predicate)**.  
Говорят, что $R$ _истинен_ на $(s_1, \, \ldots \, s_n)$,
если $(s_1, \, \ldots \, s_n) \in R$.
Часто это утверждение записывается как $R(s_1, \, \ldots \, s_n)$.

Двуместное отношение $F \subseteq S \times T$ можно назвать **функцией** из $S$ в $T$.  
_Областью определения (domain)_ $F$ называется множество $s \in S$, таких что $(s, t) \in F$ для некоторого $t$.  
_Областью значений (codomain)_ — множество $t \in T$, таких что $(s, t) \in F$ для некоторого $s$.

Митчелл (1.6.2 отношения и функции): требования к отношению, чтобы оно могло считаться функцией.

### Суждения и индуктивные определения ###

С помощью маленьких латинских букв будем обозначать _метапеременные_,
которые заменяют обозначение конкретных объектов.

Под объектами будем понимать _символьные константы_ 
и объекты, сформированные из других объектов с помощью _n-арных операторов_ $\mathtt{op}(a_1, a_2, \, \ldots, \, a_n)$,
где $a_1, a_2, \, \ldots, \, a_n$ — объекты, а $\mathtt{op}$ — _n_-арный символ оператора.

**Суждение (judgement)** утверждает, что один или несколько объектов имеют некоторое свойство
или находятся в некотором отношении.  
Само свойство или отношение называют **формой суждения (judgement form)**.
Суждение, утверждающее, что объекты имеют это свойство или находятся в этом отношении, 
называют **инстанцией (instance)** формы суждения.
Форму суждения также можно называть _предикатом_.

**Индуктивное определение (inductive definition)** формы суждения состоит из набора _правил вывода_ вида
$$ \cfrac{J_1 \quad \ldots \quad J_k} {J} $$
где $J_1, \, \ldots \, J_k, J$ — это инстанции формы суждения.
При этом $J_i$ называют _предпосылками (premises)_, а $J$ — _заключением (conclusion)_.  
Правило без предпосылок называют _аксиомой_.

#### Пример. Натуральные числа ####

Следующие два правила формируют индуктивное определение формы суждения $x \in \mathrm{Nat}$ (это просто одноместный предикат):

$$ \cfrac{} {\mathtt{zero} \in \mathrm{Nat}} \, (N.Z)$$

$$ \cfrac{n \in \mathrm{Nat}} {\mathtt{succ}(n) \in \mathrm{Nat}} \, (N.S)$$

Фактически, мы индуктивно определили множество натуральных чисел $\mathrm{Nat}$.
Сокращённо это индуктивное определение можно записать так:

<pre>
Nat ::= <b>zero</b>
	  | <b>succ</b>(n), n ∈ Nat
</pre>

**Замечание.** Индуктивные определения позволяют с помощью конечного числа правил определить бесконечное множество суждений или объектов.

Множество, определённое с помощью правил вывода, содержит то, что находится в заключении правил, и ничего больше.

Чтобы _доказать истинность_ индуктивно определённого суждения, необходимо привести _свидетельство (evidence)_ его истинности в форме **вывода (derivation)**.
_Вывод_ — это композиция правил, начинающаяся с аксиом, и заканчивающаяся суждением, которое необходимо доказать.

**Пример.** Вывод суждения $\mathtt{succ}(\mathtt{succ}(\mathtt{zero}))) \in \mathrm{Nat}$:

$$ \cfrac { \cfrac{ \cfrac{} {\mathtt{zero} \in \mathrm{Nat}} } 
{\mathtt{succ}(\mathtt{zero})) \in \mathrm{Nat}} } 
{\mathtt{succ}(\mathtt{succ}(\mathtt{zero}))) \in \mathrm{Nat}} $$

Поиск вывода начинается снизу вверх. Нужно сравнить суждение, которое мы хотим доказать, с заключениями в правилах. 
Если среди правил есть подходящее, переходим к док-ву предпосылок, иначе доказать нельзя.

### Индукция по правилам вывода ###

Пусть $JF$ — индуктивно определённая форма суждения.  
Чтобы показать, что свойство $\Phi$ выполняется для любой выводимой (доказуемой) инстанции этого суждения,
для каждого из правил индуктивного определения

$$ \cfrac{J_1 \quad \ldots \quad J_k} {J} $$

нужно показать, что свойство $\Phi$ выполняется для заключения $J$, 
если оно выполняется для всех предпосылок правила $J_i$. 
То есть нужно показать \Phi(J) (_индуктивное заключение_) при условии $\Phi(J_1), \, \ldots, \, \Phi(J_k)$ (_индуктивные гипотезы_).

**Пример.** В случае натуральных чисел, чтобы показать, что для суждения $x \in \mathrm{Nat}$ верно свойство $\Phi$,
нужно показать:

1. $\Phi(\mathtt{zero} \in \mathrm{Nat})$.
2. $\Phi(\mathtt{succ}(n) \in \mathrm{Nat})$ при условии $\Phi(n \in \mathrm{Nat})$.

Ясно, что это в точности соответствует известному нам принципу индукции на натуральных числах.

### Примеры ###

Определим индуктивно отношение равенства $\mathrm{EqNat}(a, b)$ двух натуральных чисел $a \in \mathrm{Nat}$, $b \in \mathrm{Nat}$, 
которое для простоты будем записывать как $a = b$.

$$ \cfrac {} {\mathtt{zero} = \mathtt{zero}} \, (EqN.Z)$$

$$ \cfrac {n_1 = n_2} {\mathtt{succ}(n_1) = \mathtt{succ}(n_2)} \, (EqN.S) $$

**Лемма Nat.1.** Докажем следующее утверждение: если $x \in \mathrm{Nat}$, то $x = x$, то есть $\mathrm{EqNat}(x, x)$.
Здесь $\Phi$ это $\mathrm{EqNat}(x, x)$, а $J$ это $x \in \mathrm{Nat}$.

_Доказательство._ Индукция по выводу $x \in \mathrm{Nat}$.

1.  Правило $(N.Z)$: в качестве $x$ рассматриваем $\mathtt{zero}$.  
	У этого правила ($\mathtt{zero} \in \mathrm{Nat}$) нет предпосылок, 
	поэтому нужно просто показать, что $\mathtt{zero} = \mathtt{zero}$.
	Но это в точности утверждается в правиле $(EqN.Z)$ определения отношения равенства.
	
2.	Правило $(N.S)$: в качестве $x$ рассматриваем $\mathtt{succ}(n)$.  
	Нужно показать, что $\mathtt{succ}(n) = \mathtt{succ}(n)$.
	Индуктивная гипотеза утверждает, что $n = n$.
	Приеняем правило $(EqN.S)$.
	
Qed.

**Лемма Nat.2.** Если $\mathtt{succ}(n_1) = \mathtt{succ}(n_2)$, то $n_1 = n_2$.

_Доказательство._ Нужно провести индукцию по выводу отношения равенства.
Для начала нужно переформулировать лемму, она звучит так:  
Если $m_1 = m_2$, тогда если $m_1$ это $\mathtt{succ}(n_1)$ и $m_2$ это $\mathtt{succ}(n_2)$,
то $n_1 = n_2$.

1.  Правило $(EqN.Z)$: $\mathtt{zero}$ не имеет форму $\mathtt{succ}(\_)$,
	поэтому тривиально истинно.
	
2.	Правило $(EqN.S)$: заключение правила имеет форму $\mathtt{succ}(m_1') = \mathtt{succ}(m_2')$.
	То есть нам нужно показать, что если $\mathtt{succ}(m_1')$ это $\mathtt{succ}(n_1)$
	и $\mathtt{succ}(m_2')$ это $\mathtt{succ}(n_2)$, то $n_1 = n_2$.
	Но согласно $(EqN.S)$, $m_1 = m_2$ только если $m_1' = m_2'$. 
	Из условия $\mathtt{succ}(m_i')$ это $\mathtt{succ}(n_i)$ имеем, что $m_i'$ это $n_i$. 
	А раз $m_1' = m_2'$, то и $n_1 = n_2$.

Qed.

**Лемма Nat.3.** Если $\mathtt{succ}(n) \in \mathrm{Nat}$, то $n \in \mathrm{Nat}$.

_Доказательство._ На дом!  
Подсказка: нужно переформулировать лемму.
Если $m \in \mathrm{Nat}$, то если $m$ это $\mathtt{succ}(n)$, то $n \in \mathrm{Nat}$.

Можно давать и индуктивные определения _функций_, если рассматривать _n_-арную функцию как
_n+1_-местное отношение. 

**Функция _Sum_**. Запись функции как отношения:

$$ \cfrac {n \in \mathrm{Nat}} 
{\mathrm{Sum}(\mathtt{zero}, n, n) }$$

$$ \cfrac {\mathrm{Sum}(n, m, p)} 
{\mathrm{Sum}(\mathtt{succ}(n), m, \mathtt{succ}(p)) }$$

Более удобно записывать индуктивные определения функций явно:

$$ \mathrm{Sum}(\mathtt{zero}, n) = n $$

$$ \mathrm{Sum}(\mathtt{succ}(n), m) = \mathtt{succ}(\mathrm{Sum}(n, m))) $$

Нетрудно догадаться, что алгебраические типы данных, которые вы определяли в Haskell,
в точности являются индуктивными определениями.


#### Другие задачи ####

1. Определить индуктивно бинарное дерево (дерево это либо пустое дерево, либо узел).

2. Сформулировать принцип индукции для бинарного дерева.

3. Определить отношение «дерево не пусто».

4. Определить отношение равенства на деревьях.


## Бестиповой язык арифметических выражений LAE ##

Наш язык содержит следующие синтаксические конструкции:

* булевские константы `true` и `false`;
* условное выражение `if .. then .. else`;
* арифметические операторы `succ` (следующее число) и `pred` (предыдущее число);
* операция проверки `iszero`, которая возвращает `true` для `zero` и `false` для всех остальных чисел.

### Синтаксис ###

Опишем синтаксис нашего языка с помощью грамматики:

<pre>
t ::=						// терм
	 <b>true</b>						// константа «истина»
	 <b>false</b>						// константа «ложь»
	 <b>if</b> t <b>then</b> t <b>else</b> t		  // условное выражение
	 <b>zero</b>						// константа «ноль»
	 <b>succ</b>(t)						// следующее число
	 <b>pred</b>(t)						// предыдущее число
	 <b>iszero</b>(t)					// проверка на ноль
</pre>

**Замечание.** Эта грамматика задаёт _абстрактный синтаксис (abstract syntax)_
или представление термов в форме _абстрактного синтаксического дерева (АСД/AST)_.
Строки символов, которые читают/пишут программисты, задают _конкретный синтаксис (concrete syntax)_.  
Если говорить о компиляторах, обычно переводом конкретного синтаксиса в абстрактный занимаются
лексический и синтаксический анализаторы.

Метапеременная `t` обозначает допустимый _терм (term)_ или программу на этом языке.
Язык LAE — это множество $\mathrm{T}$ всех допустимых термов.

Альтернативный способ определить это множество (то есть синтаксис) — через _правила вывода_.

$$ \cfrac{}{ \mathtt{true} \in \mathrm{T} } \quad \cfrac{}{ \mathtt{false} \in \mathrm{T} } 
\quad \cfrac{}{ \mathtt{zero} \in \mathrm{T} }$$

$$ \cfrac{ t_1 \in \mathrm{T} }{ \mathtt{succ}(t_1) \in \mathrm{T} } 
\quad \cfrac{ t_1 \in \mathrm{T} }{ \mathtt{pred}(t_1) \in \mathrm{T} }  
\quad \cfrac{ t_1 \in \mathrm{T} }{ \mathtt{iszero}(t_1) \in \mathrm{T} } $$

$$ \cfrac{t_1 \in \mathrm{T} \quad t_2 \in \mathrm{T} \quad t_3 \in \mathrm{T} }
{ \mathtt{if} \  t_1 \  \mathtt{then} \ t_2 \  \mathtt{else} \  t_3 \in \mathrm{T} } $$

**Замечание.** Для краткости при записи термов будем использовать числовые константы (синтаксический сахар).
Например, 0 вместо `zero`, 1 вместо `succ(zero)`, 2 вместо `succ(succ(zero))` и так далее.

По синтаксису видно, что это язык для _вычисления значения выражения_.
Но к этому вернёмся позже.

#### Индукция на термах ####

Можно строить _индуктивно определённые **функции**_, действующие на множестве термов,
а также, как давать _индуктивные **доказательства** (inductive proofs)_ свойств термов.

**Пример. Функция _Consts_.** Функция $\mathrm{Consts}(t)$ возвращает множество констант, встречающихся в терме $t$.  
_Дать определение не полностью!_

$\mathrm{Consts}(\mathtt{true}) = \{\mathtt{true}\}$  
$\mathrm{Consts}(\mathtt{false}) = \{\mathtt{false}\}$  
$\mathrm{Consts}(\mathtt{zero}) = \{\mathtt{zero}\}$  
$\mathrm{Consts}(\mathtt{succ}(t_1)) = \mathrm{Consts}(t_1)$  
$\mathrm{Consts}(\mathtt{pred}(t_1)) = \mathrm{Consts}(t_1)$  
$\mathrm{Consts}(\mathtt{iszero}(t_1)) = \mathrm{Consts}(t_1)$  
$\mathrm{Consts}(\mathtt{if} \  t_1 \  \mathtt{then} \  t_2 \  \mathtt{else} \  t_3) = \mathrm{Consts}(t_1) \cup \mathrm{Consts}(t_2) \cup \mathrm{Consts}(t_3)$ 

**Задачи.**

1. Функция `size(t)` определения размера терма (количество вершин в АСД).
2. Функция `depth(t)` глубины терма (количество уровней в АСД).


## Литература ##

* Robert Harper. Practical Foundations for Programming Languages [ref](http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/practical-foundations-programming-languages).

* Бенджамин Пирс. Типы в языках программирования [ref](http://www.ozon.ru/context/detail/id/7410082/).
