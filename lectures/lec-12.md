
<!-- Модуль 2
	 (2::6) Лекция 12. Подстановки и типизация лямбда-исчисления -->

# Лямбда-исчисление LC #

## Работа над ошибками ##

### Лямбда-абстракция ###

В лямбда-абстракции формальный параметр это не подтерм. 
Абстракция производится по переменной, переменная — часть определения 
абстракции. Поэтому дерево рисовать неверно, как мы делали раньше.
_Рисуем правильно!_

Из-за этого мы неправильно реализовали тип лямбда-термов, должно быть так:

```{.lang-sml}
type variable = string

datatype term = 
	Var of variable
  | Abs of variable * term
  | App of term * term
```

### Комбинатор неподвижной точки ###

`Y` называют **комбинатором неподвижной точки**, если он даёт
неподвижную точку ($x = f(x)$):

$$\mathrm{Y}\ \mathrm{F} = \mathrm{F}\ (\mathrm{Y}\ \mathrm{F})$$

**Замечание.** Чтобы вот это имело смысл, нужно формально определить
равенство, этого мы не делали.

Для стратегии вызова по значению используется Z-комбинатор

$$\lambda f.(\lambda x. f\ (\lambda y. x\ x\ y)) (\lambda x. f\ (\lambda y. x\ x\ y))$$

Мы в прошлый раз показали, что $\mathrm{fix}\ \mathrm{F}$ переходит в 
$\mathrm{F}\ (\lambda y.\mathrm{B}\ \mathrm{B}\ y)$, 
то есть $\mathrm{F}\ (\lambda y.(\mathrm{fix}\ \mathrm{F})\ y)$,
где $\mathrm{B} = \lambda x. \mathrm{F}\ (\lambda y. x\ x\ y)$.

#### Экстенсиональность ####

Пусть есть функция `fun inc x = x + 1` и `fun inc' x = inc x`.
Что можно о них сказать о них?  
Они вычисляются в однаковые значения. Вторая функция — это обёртка для первой.

Терм $\lambda x. f\ x$, если $x \notin FV(f)$ называют $\eta$**(эта)-экспансией** терма $f$.

Кроме $\beta$-редукции, можно ввести $\eta$**-редукцию**:
$$\lambda x. f\ x \longrightarrow_{\eta} f$$

Тогда ясно, что терм $\lambda y.(\mathrm{fix}\ \mathrm{F})\ y$
является просто $\eta$-экспансией терма $\mathrm{fix}\ \mathrm{F}$,
которая нужна для того, чтобы с вызовом по значению всё было ок.

**Аксиома экстенсиональности** говорит о том, что функции можно считать
одинаковыми, если они ведут себя одинаково.

$$\forall x.f\ x = g\ x \Rightarrow f = g$$

**Пример про факториал на форуме, посмотрите!**


## Подстановка ##

Напомним, что в _операционную семантику_ для стратегии вызова _по значению_
было правило: $$\cfrac{}{(\lambda x.t_{12})\ v_2 \longrightarrow [v_2/x]t_{12}}\,\text{(E-AppAbs)}$$.

### Формальное определение ###

Нужно учесть две важных вещи:

1.	При подстановке должны заменяться только _свободные_ вхождения переменной.
	Например, $[t/x](x\ (\lambda x.x)) = t\ (\lambda x.x)$, а не $t\ (\lambda x.t)$.
	
2.	Нужно избегать _захвата_ (capture) свободных переменных.
	Например, $[y\ y/x](\lambda y.y\ x)) = \lambda y.y\ (y\ y)$ это неправильно.
	Переменная `y` была свободна в подставляемом терме, а стала связана в итоговом.
	Что делать? Переименовать переменную.

Попробуем определить подстановку.

$$\begin{array}{lcll}
[s/x]x & = & s &\\
[s/x]y & = & y & \text{if } y \neq x\\
[s/x](t_1\ t_2) & = & ([s/x]t_1)\ ([s/x]t_2) &\\
[s/x](\lambda x.t) & = & \lambda x.t &\\
[s/x](\lambda y.t) & = & \lambda y.t & \text{if } y \neq x 
	\text{ and } x \notin FV(t)\\
[s/x](\lambda y.t) & = & \lambda y.[s/x]t & \text{if } y \neq x 
	\text{ and } x \in FV(t) \text{ and } y \notin FV(s)\\
[s/x](\lambda y.t) & = & \lambda y'.[s/x](\{y'/y\}t) & \text{if } y \neq x 
	\text{ and } x \in FV(t) \text{ and } y \in FV(s) 
	\text{ and } y' \notin FV(t) \cup FV(s)\\
\end{array}$$



# Simply Typed Lambda Calculus (SLTC) #

Хотим построить типизированный язык STLC, в котором есть `Nat`, `Bool`
и примитивы лямбда-исчисления, то есть переменные, абстракции, применения.

## Типы ##

Какие типы будут в расширенном языке?

```
T ::=
	Nat
	Bool
	T -> T
```

Конструктор типа «`->`» правоассоциативен, то есть `T -> S -> U` это `T -> (S -> U)`.

## Термы ##

Не будем пока выделываться и напишем язык без вывода типов, то есть
с _явными аннотациями типов_. Будем помечать тип аргументов функции.

```
t ::= 
	true | false
	0
	succ(t) | pred(t) | iszero(t)
	if t then t else t
	x			(переменная)
	\x:T.t		(абстракция)
	t t 		(применение)
```

## Отношение типизации ##

Рассмотрим терм: `\x:Nat.succ(succ(x))`.  
Какой он имеет тип? Очевидно, это функция `Nat -> Nat`.  
А как мы это поняли? У аргумента тип подписан, это `Nat`.
Дальше типизируем тело, пытаемся нашими старыми правилами... 
_Нужно знать тип `x`_!

Нам поможет **контекст типизации** (typing context), или
_окружение типизации_ (typing environment). Будем обозначать $\Gamma$.

Контекст типизации $\Gamma$ содержит информацию о типах свободных переменных терма.
```
G ::=
	<empty>		(пустой контекст)
	G, x : T	(добавление информации о переменной)
```

Таким образом от двухместного отношения на типах и термах `t : T` переходим
к трёхместному отношению $\Gamma \vdash t : \mathtt{T}$, которое означает
«терм `t` имеет тип `T` в контексте $\Gamma$».

Пустой контекст пишем просто $\vdash t : \mathtt{T}$,  
добавление информации в контекст — оператор «`,`»:  
$\Gamma, x : \mathtt{T} \text{ if } x \notin dom(\Gamma)$,
где $dom(\Gamma)$ — это множество переменных контекста, _область определения_. 
То есть контекст — это последовательность пар (переменная, тип).

**Замечание.** Требуем, чтобы все переменные в контексте были различны!
Поскольку связанные переменные в терме всегда можно переименовать, это
не проблема.

Осталось записать **правила типизации**.

$$\cfrac{}{\Gamma \vdash \mathtt{true} : \mathtt{T}}\,\text{(T-True)}$$

остальные старые правила аналогично.

$$\cfrac{x : \mathtt{T} \in \Gamma}{\Gamma \vdash x : \mathtt{T}}\,\text{(T-Var)}$$

$$\cfrac{\Gamma, x : \mathtt{T}_1 \vdash t_2 : \mathtt{T}_2}
{\Gamma \vdash \lambda x : \mathtt{T}_1.t_2 : \mathtt{T}_1 \rightarrow \mathtt{T}_2}\,\text{(T-Abs)}$$

$$\cfrac{\Gamma \vdash t_1 : \mathtt{T}_1 \rightarrow \mathtt{T}_2 \quad \Gamma \vdash t_2 : \mathtt{T}_1}
{\Gamma \vdash t_1\ t_2 : \mathtt{T}_2}\,\text{(T-App)}$$

## Операционная семантика ##

**Значения:**

```
v ::= 
	true | false
	nv
	\x:T.t
```

**Правила вычисления:** 

$$\cfrac{t_1 \longrightarrow t_1'}{t_1\ t_2 \longrightarrow t_1'\ t_2}\,\text{(E-App1)}\qquad
\cfrac{t_2 \longrightarrow t_2'}{v_1\ t_2 \longrightarrow v_1\ t_2'}\,\text{(E-App2)}$$

$$\cfrac{}{(\lambda x : \mathtt{T}_1.t_{12})\ v_2 \longrightarrow [v_2/x]t_{12}}\,\text{(E-AppAbs)}$$

## Примеры ##

* 	`|- \x:Nat. succ(succ(x)) : Nat -> Nat`

*	`f : Nat -> Bool |- \x.if (f x) then succ(x) else pred(x) : Nat -> Nat`

## Вспомогательные леммы ##

**Лемма об инверсии.**  
Один пример: если `G |- \x:T1.t2 : R`, то `R = T1 -> R2` для некоторого
`R2` и `G, x : T1 |- t2 : R2`.

**Лемма о канонических формах.**  
Если `v` — значение типа `T1 -> T2`, то `v = \x:T1.t2`.

**Единственность типов.** (Если терм типизируем, у него один тип.)   
В любом заданном контексте типизации $\Gamma$, таком, что все $x \in FV(t)$
также $x \in dom(\Gamma)$, терм `t` имеет не более одного типа.

### Теорема о продвижении ###

Пусть `t` — _замкнутый_ терм и `t : T` (правильно типизирован).  
Тогда либо `t` является значением, либо
можно проделать шаг вычисления, т.е. сущ-ет `t'`, такой что `t -> t'`.

_Доказательство_ по индукции. Старые случаи почти пропускаем.

*	`t` — это переменная. Невозможно, так как `t` замкнут.

*	`t = \x:T.s` — это значение.

*	`t = t1 t2`. 
	Правильно типизирован, значит `|- t1 : T1 -> T2`, а также `|- t2 : T2`.
	Для `t1` выполняется предположение индукции, то есть `t1`:
	
	1.	либо значение, тогда `t1 = \x:T1.t12`, и тогда `t2` по IH:
		
		1.	либо значение, тогда правило E-AppAbs;
		2.	либо можно проделать шаг вычисления в `t2'`, тогда E-App2.
		
	2.	либо можно проделать шаг вычисления в `t1'`, тогда E-App1.
	
	


## Задания ##

1. 	Доказать, что `FV(t) <= size(t)`.
2.	Покажите, что термы `\y.(\x.x y) (\x.y)` и `\x.(\y.y x) (\z.x)` альфа-эквивалентны.


## Литература ##

*	Бенджамин Пирс, глава 9 (SLTC).
