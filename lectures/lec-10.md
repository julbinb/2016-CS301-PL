
<!-- Модуль 2
	 (2::4) Лекция 10. Теорема о сохранении. Синтаксис лямбда-исчисления -->

## Безопасность ##

**Продвижение.** Правильно типизированный терм не может быть тупиковым 
(это либо значение, либо можно проделать шаг вычисления).  
**Сохранение.** Если для правильно типизированного терма можно проделать
шаг вычисления, то полученный терм тоже правильно типизирован.
	 
#### Сохранение ####

Если `t : T` и существует `t'`, `t -> t'`, то `t' : T`.

**Замечание.** Здесь полученный (редуцированный) терм не просто типизируем,
а даже имеет тот же тип.

_Доказательство_ можно вести по индукции отношения вычисления.

*	E-IfTrue. `t -> t'` это `if true then t2 else t3 -> t2`,
	второе условие: `if true then t2 else t3 : T`, значит `t2 : T`.
	
*	E-If. `t -> t'` это `if t1 then t2 else t3 -> if t1' then t2 else t3`,
	`t1 : Bool`, `t2 : T`, `t3 : T`. Предпосылка это `t1 -> t1'`, 
	для неё выполняется предположение индукции, то есть `t1' : Bool`.
	Тогда по правилу `T-If` типизируем.

## Синтаксис лямбда-исчисления ##

### Переменные ###

Для чего в программировании нужны функции?  
Чтобы записать вычисление, которое можно выполнить для разных значений.  
Например: `fun x => x * x * x`. В лямбда-исчислении это записывается
как `\x. x * x * x`.

Я не уверена, что интуиция та же, что у Чёрча, но мне так кажется.
Когда мы пишем функцию, мы абстрагируемся от значений параметров. Поэтому
в лямбда-исчислении запись функции называется _абстракцией_.

`x` это _переменная_ (variable).  
В терме `\x. x * x * x` что является _областью видимости/действия_ (scope)
переменной `x`? Тело функции (абстракции), то есть `x * x * x`.

_Вхождением_ переменной будем называть любое её использование.

Говорят, что (вхождение) переменная `x` _связана_ (bound) в теле `t` 
лямбда-абстракции  `\x.t`, 
а `\x` — это _связывающее определение_ (binder) с телом `t`.

Фактически, `\x` это объявление _формального_ параметра.
Помните, мы говорили о том, что формальные параметры имеют область видимости?

Вхождение переменной в терм называется _свободным_ (free), если оно не 
связано никакой вышележащей абстракцией.

Терм без свободных переменных называется _замкнутым_ (closed).

Примеры: `\x.x`, `\x. x + y`, `z1 * z2 + z3`.

### Определение FV(t) ###

Обсуждение.


## Задания ##

1. 	Подтермы типизированного типизированы для `if` и `true`.
2.	Единственность типа для `iszero`.
3.	Продвижение для T-Pred и T-IsZero.
4.	Сохранение для T-Pred и T-Zero.
5.	Сохранение вторым способом для `E-PredZero`, `E-PresSucc`, `E-Pred`, `E-Succ`.


## Литература ##

*	Бенджамин Пирс, глава 8 (типизированные арифметические выражения).
