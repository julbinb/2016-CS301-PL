
<!-- Модуль 2
	 (2::5) Лекция 11. Семантика лямбда-исчисления -->

# Лямбда-исчисление LC #

## Синтаксис ##

### Определение FV(t) ###

В прошлый раз нечётко сказала: «вышележащая абстракция» это в смысле 
абстрактного синтаксического дерева.
На самом деле из этого формального определения понятно, что в примере,
который мы обсуждали на лекции, есть свободные переменнные.
Мне хотелось поспекулировать, почему это имеет смысл.

_И вообще, мы смотрим на лямбда-исчисление как на язык программирования
и с программистской точки зрения_.

И, если сказать, что «_множеством свободных переменных терма_ `t` 
(обозначается `FV(t)` от англ. free variables), будем называть множество 
переменных, имеющих в терме `t` хотя бы одно свободное вхождение»,
то сразу станет понятно.

Терм называется **замкнутым** (closed), если не содержит свободных переменных.
_Функция тождества_ замкнута. Замкнутые термы ещё называют **комбинаторами**.

## Семантика ##

### Альфа-конверсия ###

Рассмотрим термы: $\lambda x.x$ и $\lambda y.y$.
Можно ли считать их одинаковыми? У них одинаковый смысл, это 
тождественная функция. Но синтаксически они разные.

А $\lambda x.x\ z$ и $\lambda x.x\ w$? Уже разные, так как свободные
переменные разные.

Термы `t1`, `t2`, одинаковые с точностью до _переименования связанных 
переменных_, называют $\alpha$-**эквивалентными** ($t_1 =_{\alpha} t_2$). 
А переименование связанной переменной называют $\alpha$-**конверсией**.  
Будем писать $t_1 \equiv t_2$ для синтаксически идентичных термов.

А термы $x\ \lambda x.x$ и $x\ \lambda y.y$? Да, альфа-эквивалентные.

Определим функцию _переименования_ переменной $x$ в $y$ в терме $t$
$\{y/x\}\,t$, где $y \notin t$:

$$\begin{array}{lcll}
\{y/x\}\,x & \equiv & y &\\
\{y/x\}\,z & \equiv & z, & z \neq x\\
\{y/x\}\,(\lambda x.t_1) & \equiv & \lambda y.\{y/x\}\,t_1 &\\
\{y/x\}\,(\lambda z.t_1) & \equiv & \lambda z.\{y/x\}\,t_1, & z \neq x\\
\{y/x\}\,(t_1\ t_2) & \equiv & (\{y/x\}t_1)\ (\{y/x\}t_2) &\\
\end{array}
$$

Тогда $\alpha$-**конверсией** терма $t$ называют замену подтерма $\lambda x.t_1$
в терме $t$ на $\lambda y.\{y/x\}\,t_1$, при условии, что $y$ не входит в $t_1$.  
Термы $t$ и $t'$ называют $\alpha$-**эквивалентными** ($t =_{\alpha} t'$),
если $t'$ можно получить из $t$ с помощью конечного числа $\alpha$-конверсий.

### Бета-редукция ###

Программу (терм) хочется выполнить (вычислить). 
У нас есть всего три вида термов. Где может скрываться вычисление?  
В применении (аппликации) абстракции (функции) к аргументу. 

Процесс вычисления лямбда-термов называется $\beta$-**редукцией** (reduction).
Терм вида $(\lambda x.t_{12})\ t_2$ называется **редексом** (или $\beta$-редексом, redex),
иными словами, редекс — это сокращаемое выражение (_нарисовать дерево_).

В программировании мы говорим, что формальный параметр заменяется на
фактический. Так и здесь, заменяем связанную переменную в абстракции
слева на терм справа. Это называется **подстановкой** (формально определим позже)
и записывается $[t_2/x]t_{12}$ (_подстановка отличается от переименования!_).

Бета-редукция переводит редекс $(\lambda x.t_{12})\ t_2$ в терм
$[t_2/x]t_{12}$ (записывается: $(\lambda x.t_{12})\ t_2 \longrightarrow_{\beta} [t_2/x]t_{12}$),
где $[t_2/x]t_{12}$ — это терм, полученный из $t_{12}$ заменой всех
_свободных_ вхождений переменной $x$ на терм $t_2$.

Примеры: 

* 	$(\lambda x.x)\ y \longrightarrow_{\beta} y$
* 	$\lambda z.(\lambda x.z)\ y \longrightarrow_{\beta} \lambda z.z$

*	$(\lambda x_1.x_1)\ ((\lambda x_2.x_2)\ (\lambda z.(\lambda y.y)\ z))$  
	Вопрос: какой редекс редуцировать первым?
	
Ответ на этот вопрос определяется **стратегией редукции**.

1.	_Полная бета-редукция_. 
	На каждом шаге редуцировать можно любой редекс. Фактически, это
	недетерминированное вычисление.
	Возможны несколько вариантов, например (_редексы подчёркивать_): 
	
	$(\lambda x_1.x_1)\ ((\lambda x_2.x_2)\ (\lambda z.(\lambda y.y)\ z))$  
	$\longrightarrow_{\beta} (\lambda x_1.x_1)\ ((\lambda x_2.x_2)\ (\lambda z.z))$  
	$\longrightarrow_{\beta} (\lambda x_2.x_2)\ (\lambda z.z)$ 
	$\longrightarrow_{\beta} \lambda z.z$ 
	
2.	Стратегия _нормального порядка бета-редукции_ («нормальная», потому 
	что приводит к нормальной форме — терму без редексов): 
	всегда редуцируется самый левый, самый внешний (на дереве) редекс.
		
	$(\lambda x_1.x_1)\ ((\lambda x_2.x_2)\ (\lambda z.(\lambda y.y)\ z))$  
	$\longrightarrow_{\beta} (\lambda x_2.x_2)\ (\lambda z.(\lambda y.y)\ z)$  
	$\longrightarrow_{\beta} \lambda z.(\lambda y.y)\ z$ 
	$\longrightarrow_{\beta} \lambda z.z$ 

3.	Стратегия _вызова по имени_ (call by name):
	всегда редуцируется самый левый, самый внешний (на дереве) редекс,
	но редукция внутри абстракции не производится (то есть абстракция является **значением**).
	
	$(\lambda x_1.x_1)\ ((\lambda x_2.x_2)\ (\lambda z.(\lambda y.y)\ z))$  
	$\longrightarrow_{\beta} (\lambda x_2.x_2)\ (\lambda z.(\lambda y.y)\ z)$  
	$\longrightarrow_{\beta} \lambda z.(\lambda y.y)\ z$
	
4.	Стратегия _вызова по значению_ (call by value):
	всегда редуцируется самый левый, самый внешний (на дереве) редекс, правая часть
	которого уже вычислена, то есть является **значением** 
	(значением является абстракция).
	
	$(\lambda x_1.x_1)\ ((\lambda x_2.x_2)\ (\lambda z.(\lambda y.y)\ z))$  
	$\longrightarrow_{\beta} (\lambda x_1.x_1)\ (\lambda z.(\lambda y.y)\ z)$  
	$\longrightarrow_{\beta} \lambda z.(\lambda y.y)\ z$ 
	
Что с термом $\lambda x.(\lambda y. x y) ((\lambda z.z) x)$?
Это абстракция, он не вычисляется.

### Операционная семантика ###

Определеним операционную семантику для стратегии вызова по значению.

Термы:  
`t ::= x | \x.t | t t`

Значения (только лямбда-абстракция):  
`v ::= \x.t` (значение-абстракция)

**Правила вычисления:** (будем использовать обычную стрелочку)

$$\cfrac{t_1 \longrightarrow t_1'}{t_1\ t_2 \longrightarrow t_1'\ t_2}\,\text{(E-App1)}\qquad
\cfrac{t_2 \longrightarrow t_2'}{v_1\ t_2 \longrightarrow v_1\ t_2'}\,\text{(E-App2)}$$

$$\cfrac{}{(\lambda x.t_{12})\ v_2 \longrightarrow [v_2/x]t_{12}}\,\text{(E-AppAbs)}$$

### Подстановка ###

Нужно учесть две важных вещи:

1.	При подстановке должны заменяться только _свободные_ вхождения переменной.
	Например, $[t/x](x\ (\lambda x.x)) = t\ (\lambda x.x)$, а не $t\ (\lambda x.t)$.
	
2.	Нужно избегать _захвата_ (capture) свободных переменных.
	Например, $[y\ y/x](\lambda y.y\ x)) = \lambda y.y\ (y\ y)$ это неправильно.
	Переменная `y` была свободна в подставляемом терме, а стала связана в итоговом.

Попробуем определить подстановку.

$$\begin{array}{lcll}
[s/x]x & = & s &\\
[s/x]y & = & y & \text{if } y \neq x\\
[s/x](t_1\ t_2) & = & ([s/x]t_1)\ ([s/x]t_2) &\\
[s/x](\lambda x.t) & = & \lambda x.t &\\
[s/x](\lambda y.t) & = & \lambda y.[s/x]t & \text{if } y \neq x \text{ and } y \notin FV(s)\\
[s/x](\lambda y.t) & = & \lambda y'.[s/x](\{y'/y\}t) & \text{if } y \neq x \text{ and } y \in FV(s) \text{ and } y' fresh\\
\end{array}$$

«fresh» — это свежая переменная, то есть совсем новая, которая 
не встречается ни в `s`, ни в `t`.

## Программирование на языке лямбда-исчисления ##

Я смотрела доклад Джона Хьюза Why Funcinal Programming Matters по 
функциональному программированию (шведский учёный, автор QuickCheck 
генератора тестов, работает над Haskell). 
Он очень забавно начинал доклад: в 1940 языки программирования были 
минималистичны. Кому нужен boolean?! Есть же лямбда-исчисление и функции.

Он ещё говорил, что в первых версиях GHC так и было (кроме чисел).

Логические значения нужны, чтобы делать выбор. 
Можно закодировать булевы константы (`true`/`false` просто 
обозначения для термов).

`true = \t.\f.t`, `false = \t.\f.f`

Это называется **булевскими константами Чёрча**.

Условное выражение: `test b p q` переводится в `p`, если `b = true`.
`test = \c.\t.\e. c t e`. Проверить на `test true p q`.

Определим функцию и: `and = \b. \c. b c false`.

### Расходящийся комбинатор ###

Помните терм омега? Это _расходящийся комбинатор_ (divergent combinator).

$$omega = (\lambda x. x\ )\ (\lambda x. x\ x)$$

Попробуем его вычислить:

$omega = (\lambda x. x\ x)\ (\lambda x. x\ x)$  
$\longrightarrow (\lambda x. x\ x)\ (\lambda x. x\ x)$

Получили снова `omega`. То есть этот терм _расходится_ (diverge).


## Язык LCNB ##

Можно закодировать всё в исходном лямбда-исчислении. Но мы добавим в него
уже известные нам ранее булевские константы и натуральные числа, а также
`not`, `and`, `or`.


## Задания ##

1. 	Доказать, что `FV(t) <= size(t)`.
2.	Покажите, что термы `\y.(\x.x y) (\x.y)` и `\x.(\y.y x) (\z.x)` альфа-эквивалентны.


## Литература ##

*	Бенджамин Пирс, глава 8 (типизированные арифметические выражения).
