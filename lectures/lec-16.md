
<!-- Модуль 2
	 (2::10) Лекция 16. Реконструкция типов и параметрический полиморфизм -->

# Реконструкция типов #

## Типизация на основе ограничений ##

Дописать правила типизации с ограничениями.  
_Замечание._  Вместо $FV(\mathtt{T})$ использую 
$TV(\mathtt{T})$ — типовые переменные.

#### Сохранение типизации при подстановке ####

**Теорема.** Если $\Gamma \vdash t : \mathtt{T}$, то 
$\sigma\Gamma \vdash t : \sigma\mathtt{T}$.

_Доказательство._ Индукция по отношению типизации.

*	Правило T-App:  
	$\cfrac{\Gamma \vdash t_1 : \mathtt{T}_1 \rightarrow \mathtt{T}_2 \quad \Gamma \vdash t_2 : \mathtt{T}_1}
	{\Gamma \vdash t_1\ t_2 : \mathtt{T}_2}$

	По индуктивной гипотезе: $\Gamma \vdash t_1 : \sigma\mathtt{T}_1 \rightarrow \sigma\mathtt{T}_2$,
	$\Gamma \vdash t_2 : \sigma\mathtt{T}_1$, значит применимо правило T-App.

#### Решение типизации с ограничениями ####

Пусть $\Gamma \vdash t : \mathtt{S}\,|\,C$.
**Решением** для $(\Gamma, t, \mathtt{S}, C)$ называется такая пара 
$(\sigma, \mathtt{T})$, что $\sigma$ удовлетворяет ограничениям $C$, 
а $\sigma\mathtt{S} = \mathtt{T}$.

### Эквивалентность определений ###

Правила типизации с ограничениями позволяют легко построить алгоритм
типизации с выводом типов, т.е. алгоритм типизации термов без аннотаций
типов.

И этот алгоритм корректен. Можно сформулировать корректность в обе
стороны, но мы только в одну.

**Теорема.** Пусть $\Gamma \vdash t : \mathtt{S}\,|\,C$.
Если $(\sigma, \mathtt{T})$ является _решением_ $(\Gamma, t, \mathtt{S}, C)$,
то оно также является решением $(\Gamma, t)$.

Доказывать не будем.

## Алгоритм унификации ##

Напишем **алгорит унификации ограничений Хиндли-Милнера**,
который используется в основе языков типа Haskell/SML (в базовых версиях,
без всяких расширений).

**Главным унификатором (наиболее общим унификатором)** множества
ограничений $C$ называется подстановка $\sigma$, которая удовлетворяет $C$,
и при этом является наиболее общей, то есть $\sigma \sqsubseteq \sigma'$
для любой $\sigma'$, удовлетворяющей $C$.

Записать алгоритм унификации.  

**Теорема.** 

* 	Алгоритм `unify` всегда завершается.
* 	Если на входе невыполнимый набор ограничений, он терпит неудачу,
	иначе возвращает главный унификатор.


**Главным решением** $\Gamma \vdash t : \mathtt{S}\,|\,C$ называется 
такое решение $(\sigma, \mathtt{T})$, что если $(\sigma', \mathtt{T}')$
тоже решение, то $\sigma \sqsubseteq \sigma'$.  
Если $(\sigma, \mathtt{T})$ — главное решение, то `T` называют
**главным типом** (principal type) терма `t` в контексте $\Gamma$.

Таким образом, типизация с ограничениями и алгоритм унификации позволяют
найти главный тип терма.

Рассмотреть пример из прошлой лекции.

# Параметрический полиморфизм #

Напомните, зачем нам нужны функции?

Аналогично, вместо набора функций `doubleNat`, `doubleBool`,
`doubleNatNat` хочется написать одну функцию, в которой 
_абстрагирован тип_. Т.е. обобщённую функцию.  
А потом инстанцировать эту обобщённую функцию конкретными типами.

Это называется **параметрическим полиморфизмом**.

Если расширить простое типизированное лямбда-исчисление параметрическим
полиморфизмом, получается _Система F_ (System F), или
_полиморфное лямбда-исчисление_.

Множество термов расширяется термами:

* 	$\lambda \mathtt{X}.t$ (абстракция типа)
*	$t\ [\mathtt{T}]$ (применение типа) это для инстанцирования.

Множество значений расширяется $\lambda \mathtt{X}.t$.

Множество типов типовыми переменными `X` и универсальным типом 
$\forall\mathtt{X}.\mathtt{T}$

В контекст добавляется связывание типовой переменной $\Gamma, \mathtt{X}$.

Расширяются правила типизации и правила вычисления.

## Свойства ##

Типобезопасность доказать можно.
И все вычисления завершаются.

Хотя можно типизировать самоприменение, нельзя типизировать комбинатор omega.

Задача реконструкции типов неразрешима.

Это _импредикативный полиморфзим_.  
В случае _предикативного полиморфизма_ (как в ML), значения типовых 
переменных ограничены _монотипами_, то есть типами без кванторов.



## Задания ##


## Литература ##

*	Бенджамин Пирс, глава 23 (параметрический полиморфизм).
