
<!-- Модуль 1,2
	 (1::7, 2::1) Лекция 7. Типы в языках программирования -->

## Язык IMP^e^ — простой императивный (imperative) язык ##

#### Выполнение операторов ####

**Пустой оператор** выполнять не нужно.

**Оператор присваивания** предполагает изменение состояния.  
Состояние, полученное из $\sigma$ присваиванием переменной $x$ значения $i$,
будем записывать $\sigma[i/x]$. Оно определяется так:

$$\sigma[i/x](y) = \begin{cases}
	i, & \text{если } y = x\\
	\sigma(y), & \text{если } y \neq x\\
\end{cases}$$

Теперь правила вычисления:

$$\cfrac{\langle a, \sigma \rangle  \longrightarrow \langle a', \sigma \rangle}
	{\langle x := a, \sigma \rangle  \longrightarrow \langle x := a', \sigma \rangle}\, (\text{E-Assign})$$
	
А если значение уже вычислено:

$$\cfrac{}{\langle x := i, \sigma \rangle  \longrightarrow \langle \mathtt{skip}, \sigma[i/x] \rangle}\, (\text{E-Var})$$

Выполнили оператор присваивания и в новой конфигурации заменили его на пустой оператор.

**Последовательность операторов.**

$$\cfrac{\langle s_1, \sigma \rangle  \longrightarrow \langle s_1', \sigma' \rangle}
	{\langle s_1\ ; s_2, \sigma \rangle  \longrightarrow \langle s_1'\ ; s_2, \sigma' \rangle}\, (\text{E-SeqFirst})$$

$$\cfrac{}{\langle \mathtt{skip}\ ; s_2, \sigma \rangle  \longrightarrow \langle s_2, \sigma \rangle}\, (\text{E-Seq})$$

**Условный оператор.** 

$$\cfrac{}{\langle \mathtt{if}\ \mathtt{true}\ \mathtt{then}\ s_1\ \mathtt{else}\ s_2, \sigma \rangle  
	\longrightarrow \langle s_1, \sigma \rangle}\, (\text{E-IfTrue})
\qquad
\cfrac{}{\langle \mathtt{if}\ \mathtt{false}\ \mathtt{then}\ s_1\ \mathtt{else}\ s_2, \sigma \rangle  
	\longrightarrow \langle s_2, \sigma \rangle}\, (\text{E-IfFalse})$$

$$\cfrac{\langle b, \sigma \rangle  \longrightarrow \langle b', \sigma \rangle}
	{\langle \mathtt{if}\ b\ \mathtt{then}\ s_1\ \mathtt{else}\ s_2, \sigma \rangle  \longrightarrow \langle \mathtt{if}\ b'\ \mathtt{then}\ s_1\ \mathtt{else}\ s_2, \sigma \rangle}\, 
(\text{E-If})$$
	
**Оператор цикла.**

Значение условия нужно перевычислять на каждой итерации цикла.

$$\cfrac{}{\langle \mathtt{while}\ b\ s, \sigma \rangle  
	\longrightarrow \langle \mathtt{if}\ b\ \mathtt{then}\ (s\ ; \mathtt{while}\ b\ s)\ \mathtt{else}\ \mathtt{skip}, \sigma \rangle}\, 
(\text{E-While})$$
	
#### Выполнение программы ####	
	
Начальной конфигурацией машины для программы $s\, ; a$ является
$\langle s\, ; a, \sigma_0 \rangle$	
	
$$\cfrac{\langle s, \sigma \rangle  \longrightarrow \langle s', \sigma' \rangle}
	{\langle s\, ; a, \sigma \rangle  \longrightarrow \langle s'\, ; a, \sigma' \rangle}\, 
(\text{E-PrgmStmt})$$

Любой оператор в конце концов вычисляется в пустой оператор.
Далее переходим к вычислению выражения.

$$\cfrac{}{\langle \mathtt{skip}\, ; a, \sigma \rangle  \longrightarrow \langle a, \sigma \rangle}\,
(\text{E-Prgm})$$

#### Завершимость ####

Программа завершается корректно, если существует _финальная_ конфигурация
$\langle i, \sigma \rangle$, в которую приходит машина.

Программа завершается с ошибкой, если машина останавливается,
но не приходит в финальную конфигурацию.

Язык Тьюринг-полный, поэтому машина может никогда не остановиться.



## Теория типов ##

Возникла задолго до языков программирования!

### Решение парадокса Рассела ###

В так называемой _наивной теории множеств_ (говоря неформально), 
множество — это коллекция объектов, которая может определяться двумя способами:

*	явным перечислением элементов;
*	через предикат: $S = {x | P(x)}$

Поэтому и возникает парадокс:

$$R = \{x\ |\ x \in x\} $$

В чём проблема? В _самоприменении_. Мы применяем предикат $x \in x$
ко множеству $R$, которое само определяется при помощи этого предиката.

#### Аксиоматическая теория множеств Цермело—Френкеля ####

1908 

Одно из решений этого парадокса представляет
аксиоматическая теория множеств Цермело—Френкеля
(ZFC — Zermelo–Fraenkel set theory with the axiom of Choice).

Для формирования множеств через предикаты используется
Axiom schema of specification (Схема выделения), согласно которой  
$S = \{ x \notin A | P(x) \}$

То есть сначала нужно определить множество $A$, и только потом можно
применять предикат $P$ к элементам из $A$.

#### Теория типов Рассела ####

1902–1908

Тип — это диапазон значений (range of significance), над которым работает
предикат $P(x)$. То есть чтобы $P$ вообще был предикатом, $x$ должен
быть некоторого типа.

Индивидуальные объекты относятся к первому типу (типу первого уровня).
Множества, состоящие из объектов первого типа, имеют второй тип,
и составляются при помощи предикатов, действующих над объектами первого типа.
В свою очередь предикаты, действующие над значениями второго типа, 
участвуют в составлении множеств третьего типа и так далее.

Таким образом если у нас есть $S = \{ x | P(x) \}$,
где $P$ действует над $x$ из $T_i$, то $S$ имеет тип $T_{i + 1}$. 
И поскольку $P$ нельзя применить к $S$, парадокса не возникает.

То есть объекты, множества объектов, множества множеств объектов.

### Замечания ###

Согласно Расселу, **тип** — это диапазон значений. 
В принципе это согласуется с нашей интуицией. 
И даже утверждение о том, что $a$ имеет тип $A$,
часто пишут $a \in A$ или $a : A$.

Можно сказать иначе (Мартин-Лёф), что тип определяет способы,
которыми можно построить значения этого типа.
Или ещё: тип определяет, что это значит — «быть значением этого типа».

Теория типов понимается как область информатики, и как конкретная формальная система. 
Есть несколько теорий типов в последнем смысле.
Разные теории типов определяют разные способы конструирования типов.

*	теория типов Рассела (британский логик, математик, философ) 1902–1908;
*	типизированное лямбда-исчисление (Чёрч) ;
*	интуиционистская (конструктивная) теория типов Мартина-Лёфа 
	(Martin-Löf, шведский математик) 1972.
	
Для SLTC и ТТ Мартина-Лёфа впервые сформулировали props-as-types.

Философский момент: типы есть у всего. Тип это тоже объект, поэтому
можно говорить о типах типов.  
Замечание: в Haskell есть сорта, это и есть типы типов.
А в SML сигнатуру называют типом модуля (структуры).


## Типы в языках программирования ##

В контексте ЯП типом можно называть множество значений, которое может
храниться в переменной.

Для чего нужны типы?

1.	Выявление ошибок.
2.	Защита абстракций.
3.	Документирование.
4.	Более эффективная компиляция (в FORTRAN 1960-е... типы были введены 
	в первую очередь для ускорения вычислений, целые vs вещественные числа).

В языке SNBU мы видели ряд программ, которые ломаются во время выполнения.
Часть этих ошибок можно избежать, если предварительно типизировать программу.

Какого рода ошибки мы видели в SNBU? 

* применение `iszero`, `succ`, `pred` к не натуральному числу; 
* использование не логического значения в условии `if`.

То есть тип это не только значения, но и операции, которые можно делать
со значениями типа.

Всех этих _ошибок времени выполнения_ можно избежать, если добавить
в язык **систему типов**.

*	Википедия: СТ это некий набор правил, которые позволяют приписывать
	конструкциям языка типы.

*	Пирс: гибко управляемый синтаксический метод доказательства  
	отсутствия в программе определённых видов поведения при помощи 
	_классификации выражений_ языка по разновидностям вычисляемых ими значений.

**Часто говорят, что система типов** — это легковесный (облегчённый)
_формальный метод_, который позволяет проверить некоторые свойства _программы_.

Разные системы типов позволяют отлавливать разные виды ошибок.
Часто говорят о _выразительности_ (или выразительной силе) системы типов.  
**Компромисс**: с одной стороны, хочется писать программы, которые
делают много хороших вещей, с другой стороны, хочется, чтобы программы
содержали как можно меньше ошибок.

Классический пример компромисса: типизация условного выражения.

Например, куча языков, которые не позволяют писать в условии
условного оператора не логическое выражение.
А много ли языков, где нельзя написать применение `hd` к пустому списку?

Можно представить простую систему типов, только базовые типы и массивы.
Это может быть Тьюринг-полный язык, но удовольствия работы с ним мало.

А если можно строить классы или алгебраические типы данных, то уже другое
дело. И _защита абстракций_. Например, если АТД стек (интерфейс, например),
то не должно быть возможности сломать абстракцию и руками в стеке испортить
значения. Или обращение к приватным полям: это тоже ошибка типов.

### Некоторые понятия из типов в ЯП ###

_Статическая_ vs _динамическая_ типизация.  
_Проверка типов_ и _вывод типов_. _Аннотации типов_.

Статическая **проверка типов** — это проверка на этапе компиляции, то есть 
до того, как программа будет запущена. Чем больше статических проверок,
тем меньше ошибок будет на этапе времени выполнения.

```
fun f (x: int) =  x + 1

fun g (s: string) =  s ^ 1

fun h (s) =  s ^ 1
```

**Вывод типов** облегчает работу программиста, позволяя не писать
аннотации типов полностью. Вывод типов выполняется на этапе компиляции,
часто сочетается с проверкой типов.

Конечно, всё это даётся не бесплатно. Часто полностью не писать аннотации
нельзя, иначе задача построения алгоритм вывода и проверки типов становится
неразрешимой. То есть не во всех случаях можно вывести тип.

Динамическая (латентная) типизация это вообще говоря некорректный термин,
это уже не типизация, а проверка типов.
Это означает, что уже на этапе времени выполнения выполняются некоторые 
проверки типов. Пока программа не выполнится, ничего об объектах сказать
нельзя. И тип объектов может меняться, так как меняются значения.

Во многих известных вам языках сочетается статическая и динамическая типизация.
Например, приведение типов вниз от базовых классов к наследникам
проверяется динамически, на этапе времени выполнения.

Сейчас ещё модное направление — _gradual typing_ (последовательная типизация).
Часть объектов типизируется статически, а часть динамически.

#### О безопасности ####

Пирс называет безопасным языком такой язык, который защищает свои 
собственные абстракции.

Бывают ошибки, которые моментально приводят к остановке программы
(диагностируемые) как деление на ноль, и недиагностируемые.

### Интересные типы ###

Подтипирование, полиморфизм.

Нетривиальный полиморфизм (импредикативный):

	fun (x: ?) = x x

#### Зависимые типы ####

Мега-популярное направление:  
**Зависимые типы** (dependent types). Это типы, которые зависят от значений.
Например, `vector (n: nat)` — это тип векторов из `n` элементов.

Зависимые типы рассматривались ещё у Мартина-Лёфа. На их основе
системы доказательств теорем Coq, Agda, Idris.

Мы знаем алгебраические типы данных и конструкторы типа как функции

	datatype term =   True			// True: term
					| IntC of int   // IntC: int -> term
	
	datatype nat = Zero				// Zero : nat
				 | Succ of nat		// Succ : nat -> nat
					
Аналогично можно рассматривать типы типов.

	int :: Type
	term :: Type	
	nat :: Type
	
Полиморфные типы мы приблизительно знаем:

	datatype 'a list = 	  
		Nil						// Nil : 'a list
	  | Cons of 'a * 'a list	// Cons : 'a * 'a list -> 'a list
						
	list :: Type -> Type
	
А можно ввести зависимые типы, классический пример — 
вектор фиксированной длины. Здесь уже не от типа зависит, а от терма:

	intvec :: nat -> Type
	
	datatype intvec (nat) = 
		Empty(Zero)				// Empty : intvec(Zero)
	  | {n : nat} Cons(n + 1) of int * intvec(n) 
		// Cons : int * intvec(n) -> intvec (Succ n)
	  
Можно определить и полиморфный зависимый тип.
	
	datatype 'a vector (nat) = 
		Empty(Zero)					// Empty : 'a vector(Zero)
	  | {n : nat} Cons(n + 1) of 'a * 'a vector(n) 
		// Cons: : 'a * 'a vector (n) -> 'a vector (Succ n)
		
	vector :: Type -> nat -> Type

Основная сложность здесь в том, что стирается различие между типом и термом.
На этапе компиляции приходится выполнять некоторые вычисления.

	val first : {n : nat} 'a vector(Succ n) -> 'a
	
Имея зависимые типы, отношения тоже можно кодировать:

	datatype leq (nat * nat) = 
		{n : nat} LeqN(n, n)		// LeqN : leq(n, n)
	  | {n : nat, m : nat} LeqSucc(n, Succ m) of leq(n, m)
		// LeqSucc : leq(n, m) -> leq(n, Succ m)
		
Пользуясь этим, можно написать функцию обращения к i-му элементу вектора.

Помните, мы говорили о _свидетельствах_ в интуиционистской логике?
Вот таки вот объекты и есть свидетельства. Свидетельством того, что
leq(5, 6) является значение соответствующего типа.

#### Уточнённые типы ####

**Refinement types** тоже активно развиваются.

Уточнённый тип — это тип плюс предикат. Например:

	reftype posInt = {x : int | x > 0 }
	
	fun filterPos (xs : int list) : posInt list = 
		filter (fn x => x > 0)
		
Проверка типов в уточнённых типах проводится с помощью SMT-solvers (решателей),
которые разрешают уравнения. Поэтому предикаты имеют ограниченную форму.

Хорошее объяснение, в чём разница: в случае зависимых типов
все предикаты — это типы данных. И нужно при написании программ 
предоставлять в явном виде такие свидетельства.
В случае уточнённых типов эти вещи делаются автоматически.

_SMT_ (Satisfiability modulo theories, Задача выполнимости формул в теориях)
SMT-решатели решают задачу разрешимости логческих формул 
(обычно первого порядка, то есть без кванторов).  
Есть Boolean satisfiability problem SAT (Задача выполнимости булевых формул):
нужно расставить значения так, чтобы получилась истинная формула.  
Аналогично работают SMT для целых и вещесвтенных чисел, списков и так далее.



## Задания ##


## Литература ##

*	http://plato.stanford.edu/entries/type-theory/

*	http://www.math.ups.edu/~bryans/Current/Journal_Spring_1999/JEarly_232_S99.html

*	http://fair-use.org/bertrand-russell/the-principles-of-mathematics/appendix-b

*	http://homes.soic.indiana.edu/jsiek/what-is-gradual-typing/

*	Type Systems. Luca Cardelli

*	https://www.cs.bu.edu/~hwxi/DML/DML.html

*	http://cs.stackexchange.com/questions/21728/dependent-types-vs-refinement-types

*	http://cstheory.stackexchange.com/questions/16953/constraint-types-ibm-x10-compared-to-dependent-types
