
### 2. Денотационная семантика (продолжение) ###

В качестве семантического домена можно рассматривать и, например,
объектный код. Тогда компиляция представляет собой функцию интерпретации.


### 1. Аксиоматическая семантика ### 

Позволяет выводить и доказывать свойства о программах и их частях, то есть аксиоматическая семантика — это некоторая логическая система.
Смысл программы (или терма) — это то, что о нём можно доказать.

Определение аксиоматической семантики включает аксиомы и правила вывода.

#### Пример A. Аксиоматика равенства ####

Позволяет рассуждать об эквивалентности программ, даёт основание 
заменять одни части программ другими.

$$\cfrac{}{t = t}$$
$$\cfrac{}{\mathtt{if}\ true\ \mathtt{then}\ t_1\ \mathtt{else}\ t_2 = t_1}$$
$$\cfrac{t_1 = t_2}{t_2 = t_1}$$

$$\cfrac{t_c = t_c' \quad t_1 = t_1' \quad t_2 = t_2'}
{\mathtt{if}\ t_c\ \mathtt{then}\ t_1\ \mathtt{else}\ t_2 
= \mathtt{if}\ t_c'\ \mathtt{then}\ t_1'\ \mathtt{else}\ t_2'}$$

$$\cfrac{}{\mathtt{pred}(\mathtt{succ}(t)) = t}$$

Корректность аксиоматической семантики относительно денотационной:
если можно вывести равенство термов в АС, то в ДС они должны имет одинаковые значения.
И наоборот.

#### Пример B. Логика Хоара ####

Тони Хоар (английский учёный, сэр Чарльз Энтони Ричард Хоар, рыцарское звание), 1969. Быстрая сортировка.
Изучал русский, обучался по обмену в МГУ.
Согласно википедии, извинялся за изобретение Null reference в ALGOL W.

Это формальная система, которая в позволяет доказывать утверждения 
об императивных программах. 

Основным элементом логики Хоара являются _тройки Хоара_:

$$\{P\}\, C\, \{Q\}$$

$C$ — это команда языка, $P$ и $Q$ — _утверждения_ (assertions)
о состоянии вычислений до и после выполнения команды.
То есть _предусловие_ (precondition) и _постусловие (postcondition)_ соответственно.

Тройка описывает следующее утверждение:  
если команда $C$ выполняется в состоянии, где истинно $P$, и $C$ завершается,
то команда завершается в состоянии, где истинно $Q$.

Примеры: аксиома пустого оператора, правило композиции.

$$\cfrac{}{\{P\}\, \mathtt{skip}\, \{P\}}$$

$$\cfrac{\{P\}\, C_1\, \{Q\} \quad \{Q\}\, C_2\, \{R\}}
{\{P\}\, C_1;\, C_2\, \{R\}}$$


### 3. Операционная семантика ###

Есть операционная семантика с **малым шагом** (структурная операционная семантика/редукционная семантика),
и операционная семантика с _большим шагом_ (естественная семантика). Ко второй вернёмся позже.

Что хочется сделать с термом `if iszero(zero) then succ(zero) else pred(succ(succ(zero)))`?
Вычислить или редуцировать.

Операционная семантика задаёт способ _символьного вычисления_ (evaluation) или выполнения (execution) термов.
В отличие от компиляции, когда программа на одном языке переводится в программу на другом и затем исполняется,
операционная семантика подобна _интерпретатору_, который работает с программами (термами) на исходном языке, исполняет их.

То есть мы берём терм и вычисляем (редуцируем) его, пока это возможно.

Операционная семантика определяет _абстрактную машину_ (abstract machine) для вычисления термов.
_Состояния_ — это термы, а поведение машины задаётся _функцией перехода_, которая либо указывает следующее состояние машины (если можно сделать шаг редукции), либо объявляет машину остановившейся.\
Формально чаще всего операционную семантику задают как _отношение вычисления_ на термах.

_Смыслом_ терма `t` является конечное состояние, которого достигает машина, запущенная в начальном состоянии `t`.

Очевидно, операционная семантика должна быть корректной относительно других форм семантики.

#### Операционная семантика SNBU ####

Когда задаём отношение вычисления, нужно либо показать, как вычисляется терм, либо остановиться.
В автоматах задавалось множество финальных состояний. Аналогично, здесь задаётся множество _значений_ — то есть подмножество термов, которые считаются финальными состояниями.

Значения будем обозначать с помощью метапеременной `v`.

<pre>
v ::=			// значения
		true
		false
		nv		// числовые значения

nv ::=
		0			// ноль
		succ(nv)	// значение-последователь
</pre>

Аксиомы для краткости будем записывать без верхней черты.
**Отношение одношагового вычисления** (evaluation) на множестве термов будем записывать как $t \longrightarrow t'$, где $t, t' \in T$.

Написать плохое отношение `iszero(succ(t1))` вместо `iszero(succ(nv1))`.
И забыть про `pred(succ(nv1))`.

$$\mathtt{if}\ \mathtt{true}\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 
	\longrightarrow t_2 (\text{E-IfTrue})$$
$$\mathtt{if}\ \mathtt{false}\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 
	\longrightarrow t_3 (\text{E-IfFalse})$$
	
$$\cfrac{t_1 \longrightarrow t_1'}
	{\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 \longrightarrow \mathtt{if}\ t_1'\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3} (\text{E-If})$$
	
$$\mathtt{iszero}(0) \longrightarrow \mathtt{true} (\text{E-IszeroZero})$$
$$\mathtt{iszero}(\mathtt{succ}(nv_1)) \longrightarrow \mathtt{false} (\text{E-IszeroSucc})$$

$$\cfrac{t_1 \longrightarrow t_1'}
	{\mathtt{iszero}(t_1) \longrightarrow \mathtt{iszero}(t_1')} (\text{E-Iszero})$$
	
$$\cfrac{t_1 \longrightarrow t_1'}
	{\mathtt{succ}(t_1) \longrightarrow \mathtt{succ}(t_1')} (\text{E-Succ})$$

$$\mathtt{pred}(0) \longrightarrow 0 (\text{E-PredZero})$$	
$$\mathtt{pred}(\mathtt{succ}(nv_1)) \longrightarrow nv_1 (\text{E-PredSucc})$$

$$\cfrac{t_1 \longrightarrow t_1'}
	{\mathtt{pred}(t_1) \longrightarrow \mathtt{pred}(t_1')} (\text{E-Pred})$$

Рассмотреть на примере `if iszero(0) then false else succ(0)`
и `if iszero(succ(pred(0))) then succ(succ(0)) else pred(succ(0))`.\
Во втором примере применимы два правила: E-Iszero и E-IszeroSucc.
Мы получили _недетерминированность_ вычисления, что не очень хорошо.
Ещё одна проблема: `iszero(succ(true))` можно вычислить в `false`, что тоже странно.

Исправляем правила... Получили вычисление, управляемое синтаксисом (syntax-driven evaluation).
Теперь оно детерминированное. 

**Замечание.** Значения никогда не появляются в левой части отношений, они ни во что не вычисляются, являются финальными.

_Стратегия вычисления_ (evaluation strategy) для условных выражений: пока не вычислили условие, дальше не идём.
Правила E-IfTrue/E-IfFalse — рабочие правила (computation rules) (проделывают работу по вычислению), а
E-If это правило соответствия (congruence rule) (помогает определить, где работа должна выполняться).
Ещё рабочие правила: E-IszeroZero, E-IszeroSucc, E-PredZero, E-PredSucc. Соответствия: E-Iszero, E-Succ, E-Pred.

_Инстанцией_ (instance) правила будем называть правило, полученное заменой каждой метапеременной на один и тот же терм.
Например,
$\mathtt{if}\ \mathtt{false}\ \mathtt{then}\ \mathtt{true}\ \mathtt{else}\ \mathtt{succ}(0) 
	\longrightarrow \mathtt{succ}(0)$
является инстанцией правила E-IfFalse.

Чтобы обосновать выполнимость одношагового вычисления $t \longrightarrow t'$, нужно привести вывод соответствующего отношения. Пример: `if iszero(pred(0)) then succ(0) else true -> if iszero(0) then succ(0) else true`.

**Теорема** (Детерминированность одношагового вычисления).
Если $t \longrightarrow t'$ и $t \longrightarrow t''$, то $t' = t''$.\
_Доказательство._ (Индукция по выводу $t \longrightarrow t'$).

* 	Для каждого правила, определяющего вычисление, показываем, что 
	если посылка детерминированна, то и заключение детерминированно.

*	Пусть последнее правило `t -> t'` это `if true then t2 else t3 -> true`.
	Какие могут быть варианты отношения `t -> t''`?
	
	E-IfFalse не подходит, E-If тоже, так как `true` не может ни во что перейти (кстати, почему? Потому что `true` нет в левой части отношения вычисления).
	Все остальные правила тоже не подходят, так как левая часть в них имеет совсем другую форму.\
	Значит последним правилом может быть только E-IfTrue, но это значит, что `t' = t''`.
	
* 	Пусть последнее правило `t -> t'` это `iszero(t1) -> iszero(t1')`.
	Для посылки `t1 -> t1'` выполняется индуктивная гипотеза.
	
	Последним правилом в `t -> t''` не могут быть E-If\*, E-Succ\* и E-Pred\*, так как они имеют другой вид терма слева.\
	Это не может быть E-IszeroZero, так как 0 не может ни во что переходить, как и `succ(nv1)` в E-IszeroSucc.
	Значит это правило E-Iszero. То есть отношение имеет вид
	`iszero(t1) -> iszero(t1'')` и выполянется `t1 -> t1''`. 
	Применим правило индукции: `t1 = t1''`. Значит и заключение правила такое же.
	
На дом: правило E-If и E-PredZero.

**Определение.** Говорят, что терм $t$ находится в **нормальной форме**, если к нему не применимо никакое правило вычисления.
То есть не существует такого $t'$, что $t \longrightarrow t'$.

**Лемма.** Всякое значение находится в нормальной форме.\
Это, собственно говоря, по определению. Значения это такие термы, которые дальше не вычисляются. Это должно соблюдаться.

А что с термом `succ(true)`? Он находится в нормальной форме (так как нет подходящего правила для его вычисления),
но он не является значением. Такие термы будем называть _тупиковыми_ (stuck).

**Определение.** Терм называется **тупиковым** (stuck), если он находится в нормальной форме, но не является значением.
Тупиковый терм, очевидно, соответствует _ошибке времени выполнения_. Машина не знает, что делать дальше, так как программа оказалась в бессмысленном состоянии.

**Определение.** _Отношение многошагового вычисления_ (multi-step evaluation relation) $\longrightarrow^*$ — это рефлексивно-транзитивное замыкание отношения одношагового вычисления. То есть:

1.	Если $t \longrightarrow t'$, то $t \longrightarrow^* t'$.
2.	Для всех $t$ верно $t \longrightarrow^* t$ (рефлексивность).
3.	Если $t \longrightarrow^* t'$ и $t' \longrightarrow^* t''$, то $t \longrightarrow^* t''$ (транзитивность).

**Лемма.** Если $t1 \longrightarrow^* t1'$, 
то $\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 \longrightarrow^* \mathtt{if}\ t_1'\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3$.\
_Доказательство._ Индукция по $t_1 \longrightarrow^* t_1'$.

Аналогично для `iszero` на дом.

#### Операционная семантика с большим шагом ####

Это отношение определяет, во что вычисляется терм, то есть показывает, как сразу перейти к значению: $t \Downarrow v$

$$v \Downarrow v\ (\text{B-Val})$$

$$\cfrac{t_1 \Downarrow \mathtt{true} \quad t_2 \Downarrow v_2}
	{\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 
	\Downarrow v_2} (\text{B-IfTrue})$$
$$\cfrac{t_1 \Downarrow \mathtt{false} \quad t_3 \Downarrow v_3}
	{\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 
	\Downarrow v_3} (\text{B-IfFalse})$$
	
$$\cfrac{t_1 \Downarrow 0}
	{\mathtt{iszero}(t_1) \Downarrow \mathtt{true}} (\text{B-IszeroTrue})$$
$$\cfrac{t_1 \Downarrow \mathtt{succ}(nv_1)}
	{\mathtt{iszero}(t_1) \Downarrow \mathtt{false}} (\text{B-IszeroFalse})$$
	
$$\cfrac{t_1 \Downarrow nv_1}
	{\mathtt{succ}(t_1) \Downarrow \mathtt{succ}(nv_1)} (\text{B-Succ})$$

$$\cfrac{t_1 \Downarrow 0}
	{\mathtt{pred}(t_1) \Downarrow 0} (\text{B-PredZero})$$
$$\cfrac{t_1 \Downarrow \mathtt{succ}(nv_1)}
	{\mathtt{pred}(t_1) \Downarrow nv_1} (\text{B-PredSucc})$$
	
**Теорема.** Если $t \Downarrow v$, то $t \longrightarrow^* v$.\
_Доказательство._ 

*	Вариант B-IfTrue. В $t \Downarrow v$ $t = \mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3$,
	$t_1 \Downarrow \mathtt{true}$, $t_2 \Downarrow v_2$.
	
	По предположению индукции для предпосылок выполняется, то есть 
	$t_1 \longrightarrow^* \mathtt{true}$, $t_2 \longrightarrow^* v_2$.
	По лемме из $t_1 \longrightarrow^* \mathtt{true}$ имеем, что
	$\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 \longrightarrow^* \mathtt{if}\ \mathtt{true}\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3$. Значит по E-IfTrue 
	$\mathtt{if}\ \mathtt{true}\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3 \longrightarrow^* t_2$.
	Из этого и $t_2 \longrightarrow^* v_2$ по транзитивности получаем нужное.


## Литература ##
	
* 	Бенджамин Пирс. Типы в языках программирования [ref](http://www.ozon.ru/context/detail/id/7410082/).
	3.5.
	
