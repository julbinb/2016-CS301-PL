<!-- об индуктивных определениях -->

**Вопрос.** Почему принцип индукции по правилам вывода работает?

**Наименьшая неподвижная точка**.  
Элемент $p$ множества $E$ называют
_неподвижной точкой_ отображения $f: E \rightarrow E$, если $f(p) = p$.  
Элемент $m$ упорядоченного множества $E$ называют _наименьшей_ неподвижной точкой
отображения $f: E \rightarrow E$, если он является наименьшим во множестве
всех неподвижных точек отображения $f$.

Есть теоремы о неподвижной точке (например, теорема Клини), 
которые доказывают существование наименьших неподвижных точек на 
множествах с определёнными видами порядков.
В частности, на множестве с отношением сильно полного порядка 
(strongly complete ordering relation).  
Примером такого отношения является отношение вложения 
на множестве всех подмножеств.

Подмножество $E \subseteq A$ называют _замкнутым_ относительно действия
$f$ из $A^n$ в $A$, если для любых $a_1, \ \ldots, \ a_n$ элемент
$f a_1, \ \ldots, \ a_n \in E$.

**Индуктивные определения**.  
Пусть $A$ — множество. _Индуктивным определением_ $E \subseteq A$ называют
семейство частичных функций $f_1$ из $A^{n_1}$ в $A$, $\ldots$, $f_k$ из $A^{n_k}$ в $A$.
$E$ определяется как наименьшее замкнутое относительно действия функций
$f_1, \ \ldots, \ f_k$ подмножество $A$.  
Функции $f_i$ называют _правилами вывода_ и вместо $f_i: x_1, \ \ldots, \ x_{n_i} \mapsto t$
пишут

$$\cfrac{x_1 \quad \ldots \quad x_{n_i}}{t} \, (f_i)$$

Пользуясь теоремами о неподвижной точке можно показать, что 
эквивалентным образом $E$ можно определить как множество $x \in A$, 
для которых существует _вывод_ по правилам $f_i$.

_Принцип структурной индукции (по правилам вывода)_ говорит о том, 
что если показать, что если каждый раз, когда свойство выполнено для
$y_1, \, \ldots, \, y_{n_i}$, оно также выполняется и для $f_i \ y_1, \, \ldots, \, y_{n_i}$,
то можно заключить, что это свойство присуще всем элементам из $E$.  
Правильность этого принципа можно обосновать, используя теоремы о неподвижной точке.


## Бестиповой язык арифметических выражений NB-U ##

(nat bool, untyped)

Наш язык содержит следующие синтаксические конструкции:

* булевские константы `true` и `false`;
* условное выражение `if .. then .. else`;
* арифметические операторы `succ` (следующее число) и `pred` (предыдущее число);
* операция проверки `iszero`, которая возвращает `true` для `zero` и `false` для всех остальных чисел.

### Синтаксис ###

Опишем синтаксис нашего языка с помощью грамматики:

<pre>
t ::=						// терм
	 <b>true</b>						// константа «истина»
	 <b>false</b>						// константа «ложь»
	 <b>if</b> t <b>then</b> t <b>else</b> t		  // условное выражение
	 <b>zero</b>						// константа «ноль»
	 <b>succ</b>(t)						// следующее число
	 <b>pred</b>(t)						// предыдущее число
	 <b>iszero</b>(t)					// проверка на ноль
</pre>

**Замечание.** Эта грамматика задаёт _абстрактный синтаксис (abstract syntax)_
или представление термов в форме _абстрактного синтаксического дерева (АСД/AST)_.
Строки символов, которые читают/пишут программисты, задают _конкретный синтаксис (concrete syntax)_.  
Если говорить о компиляторах, обычно переводом конкретного синтаксиса в абстрактный занимаются
лексический и синтаксический анализаторы.

Метапеременная `t` обозначает допустимый _терм (term)_ или программу на этом языке.
Язык LAE — это множество $\mathrm{T}$ всех допустимых термов.

Альтернативный способ определить это множество (то есть синтаксис) — через _правила вывода_.

$$ \cfrac{}{ \mathtt{true} \in \mathrm{T} } \quad \cfrac{}{ \mathtt{false} \in \mathrm{T} } 
\quad \cfrac{}{ \mathtt{zero} \in \mathrm{T} }$$

$$ \cfrac{ t_1 \in \mathrm{T} }{ \mathtt{succ}(t_1) \in \mathrm{T} } 
\quad \cfrac{ t_1 \in \mathrm{T} }{ \mathtt{pred}(t_1) \in \mathrm{T} }  
\quad \cfrac{ t_1 \in \mathrm{T} }{ \mathtt{iszero}(t_1) \in \mathrm{T} } $$

$$ \cfrac{t_1 \in \mathrm{T} \quad t_2 \in \mathrm{T} \quad t_3 \in \mathrm{T} }
{ \mathtt{if} \  t_1 \  \mathtt{then} \ t_2 \  \mathtt{else} \  t_3 \in \mathrm{T} } $$

**Замечание.** Для краткости при записи термов будем использовать числовые константы (синтаксический сахар).
Например, 0 вместо `zero`, 1 вместо `succ(zero)`, 2 вместо `succ(succ(zero))` и так далее.

Можно предположить, что указанный язык — это язык для _вычисления значения выражений_.
К семантике мы ещё вернёмся позже, а пока давайте напишем пару примеров:

*	`if true then false else true` >>> `false`
*	`if iszero(succ(0)) then succ(1) else pred(1)` >>> `0`
*	`succ(succ(true))` >>> ошибка «времени выполнения», некорректный терм

Домашнее задание: функция проверки корректности терма.

### Индукция на термах ###

Можно строить _индуктивно определённые **функции**_, действующие на множестве термов,
а также, как давать _индуктивные **доказательства** (inductive proofs)_ свойств термов.

**Пример. Функция _Consts_.** Функция $\mathrm{Consts}(t)$ возвращает множество констант, встречающихся в терме $t$.  
_Дать определение не полностью!_

$\mathrm{Consts}(\mathtt{true}) = \{\mathtt{true}\}$  
$\mathrm{Consts}(\mathtt{false}) = \{\mathtt{false}\}$  
$\mathrm{Consts}(\mathtt{zero}) = \{\mathtt{zero}\}$  
$\mathrm{Consts}(\mathtt{succ}(t_1)) = \mathrm{Consts}(t_1)$  
$\mathrm{Consts}(\mathtt{pred}(t_1)) = \mathrm{Consts}(t_1)$  
$\mathrm{Consts}(\mathtt{iszero}(t_1)) = \mathrm{Consts}(t_1)$  
$\mathrm{Consts}(\mathtt{if} \  t_1 \  \mathtt{then} \  t_2 \  \mathtt{else} \  t_3) = \mathrm{Consts}(t_1) \cup \mathrm{Consts}(t_2) \cup \mathrm{Consts}(t_3)$ 

**Задачи.**

1. Функция `size(t)` определения размера терма (количество вершин в АСД). (на дом)
2. Функция `depth(t)` глубины терма (количество уровней в АСД). 

Рассмотреть на примере термов:

1. `true`
2. `if iszero(succ(0)) then false else pred(succ(5))`

#### Принципы индукции на термах ####

Чтобы показать, что для любого терма $s$ выполняется $P(s)$,
можно использовать один из трёх принципов индукции:

1. 	**Структурная индукция**.
	Это в точности индукция по правилам вывода, только переформулированная более удобным образом.
	
	Нужно показать, 
	что если для всех непосредственных подтермов $r$ терма $s$ $P(r)$,
	то $P(s)$.

2.	**Индукция по глубине**.
	
	Нужно показать, 
	что если $P(r)$ для всех термов $r$, таких что $depth(r) < depth(s)$,
	то $P(s)$.
	
3.	**Индукция по размеру**. На дом.	

Эти принципы выводятся друг из друга, идею обоснования последнего мы знаем.
То есть можно пользоваться любым, который нравится.

**Лемма**. Число различных констант в терме $t$ не больше его размера,
то есть $|Const(t)| \leq size(t)$. 

_Доказательство_ (структурная индукция).

1.	Вариант $t$ это константа.
2.	Вариант $t$ это `\mathtt{succ}(t_1)`, `\mathtt{pred}(t_1)` или `\mathtt{iszero}(t_1)`.
3.	Вариант $t$ это `\mathtt{if} t_1 \mathtt{then} t_2 \mathtt{else} t_3`.


## Способы определения семантики ##

Как мы уже говорили, **семантика** языка программирования задаёт **смысл программ**,
смысл в терминах некоторой формальной математической модели.
Часто говорят, что семантика определяет, как _вычисляются_ программы, 
то есть представляет собой отношение между синтаксическими конструкциями и моделью вычисления (computational model).
Также можно говорить, что семантика задаёт _интерпретацию_ программ.

Существует несколько подходов к формализации семантики, среди них обычно выделяют три основных.

### 1. Аксиоматическая семантика ### 

Позволяет выводить и доказывать свойства о программах и их частях.
Смысл программы (или терма) — это то, что о нём можно доказать.

Определение аксиоматической семантики включает аксиомы и правила вывода.

#### Пример A. Аксиоматика равенства ####

Позволяет рассуждать об эквивалентности программ, даёт основание 
заменять одни части программ другими.

$$t = t$$

$$\mathtt{if}\ true\ \mathtt{then}\ t_1\ \mathtt{else}\ t_2 = t_1$$

$$\cfrac{t_1 = t_2}{t_2 = t_1}$$

$$\cfrac{t_c = t_c' \quad t_1 = t_1' \quad t_2 = t_2'}
{\mathtt{if}\ t_c\ \mathtt{then}\ t_1\ \mathtt{else}\ t_2 
= \mathtt{if}\ t_c'\ \mathtt{then}\ t_1'\ \mathtt{else}\ t_2'}$$

#### Пример B. Логика Хоара ####

Тони Хоар, 1969. Быстрая сортировка.

Это формальная система, которая в позволяет доказывать утверждения 
об императивных программах. 

Основным элементом логики Хоара являются _тройки Хоара_:

$$\{P\}\, C\, \{Q\}$$

$C$ — это команда языка, $P$ и $Q$ — _утверждения_ (assertions)
о состоянии вычислений до и после выполнения команды.
То есть _предусловие_ (precondition) и _постусловие (postcondition)_ соответственно.

Тройка описывает следующее утверждение:  
если команда $C$ выполняется в состоянии, где истинно $P$ и $C$ завершается,
то команда завершается в состоянии, где истинно $Q$.

Примеры: аксиома пустого оператора, правило композиции.

$$\cfrac{}{\{P\}\, \mathtt{skip}\, \{P\}}$$

$$\cfrac{\{P\}\, C_1\, \{Q\} \quad \{Q\}\, C_2\, \{R\}}
{\{P\}\, C_1;\, C_2\, \{R\}}$$

### 2. Денотационная семантика ###

Дана Скотт.

В рамках этой семантики смыслом программы является некоторый математический объект.

Определение денотационной семантики включает
определение _семантических доменов (semantic domains)_, то есть область 
смыслов программ, и _функцию интерпретации (interpretation function/valuation/meaning function)_, которая
ставит в соответсвие программам элементы (те самые математические объекты)
из этих семантических доменов.

Например, в случае нашего языка, семантическими доменами являются
множество натуральных чисел и булевские константы.

В качестве семантического домена можно рассматривать и, например,
объектный код. Тогда компиляция представляет собой функцию интерпретации.

Значительный вклад в развитие этого вида семантики внёс Дана Скот.
Есть даже целая область исследований — _теория доменов (domain theory)_,
которая занимается поиском подходящих доменов для моделирования ЯП.

Важным **свойством** денотационной семантики является её
_композициональность (compositionality)_ (или индуктивность у Митчелла):
значение программы (терма) 
определяется через значения её составных частей (подтермов).

Обычно денотационную семантику определяют в виде набора:

$$[\![\mathtt{true}]\!] = true_{\mathbb{B}}$$
$$[\![\mathtt{false}]\!] = false_{\mathbb{B}}$$

$$[\![\mathtt{zero}]\!] = 0_{\mathbb{N}}$$

$$[\![\mathtt{succ}(t_1)]\!] = [\![t_1]\!] + 1,\ \text{где «+» это математическое сложение чисел}$$
$$[\![\mathtt{pred}(t_1)]\!] =
\begin{cases}
0_{\mathbb{N}}, \text{если}\ [\![t_1]\!] = 0 \\
[\![t_1]\!] - 1\ \text{иначе}\\
\end{cases}$$

$$[\![\mathtt{iszero}(t_1)]\!] =
\begin{cases}
true_{\mathbb{B}}, \text{если}\ [\![t_1]\!] = 0 \\
false_{\mathbb{B}}\ \text{иначе}\\
\end{cases}$$

$$[\![\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3]\!] =
\begin{cases}
[\![t_2]\!], \text{если}\ [\![t_1]\!]\ \text{истинно}\\
[\![t_3]\!]\ \text{иначе}\\
\end{cases}$$

Какая есть **проблема** у этого определения?  
Если мы применим функцию интерпретации к некорректному терму (`succ(true)`),
то получим ошибку, так как функция сложения не определена на `true` и `1`.

_Замечание._ Если мы пишем такую функцию на ML, то это можно моделировать
выбрасыванием искючения или получением ошибки времени выполнения.

Выход такой: 
добавить семантический домен ошибок $\mathbb{Er}$ с единственным элементом $error$.
И исправим функцию интерпретации.

$$[\![\mathtt{if}\ t_1\ \mathtt{then}\ t_2\ \mathtt{else}\ t_3]\!] =
\begin{cases}
[\![t_2]\!], \text{если}\ [\![t_1]\!]\ \text{истинно}\\
[\![t_3]\!], \text{если}\ [\![t_1]\!]\ \text{ложно}\\
error\ \text{иначе (то есть если } [\![t_1]\!] = error)\\
\end{cases}$$

Остальные правила на дом.
Если где-то возникла ошибка, она должна распространиться дальше.

## Литература ##

* 	Бенджамин Пирс. Типы в языках программирования [ref](http://www.ozon.ru/context/detail/id/7410082/).
	3.1 до 3.4.
	
*	Anthony A. Aaby. Introduction to Programming Languages. 
	3: 3.2, 3.3.

* 	Жиль Довек, Жан-Жак Леви. Введение в теорию языков программирования. 
	5.3.1.

*	Дж. Митчелл. Основания языков программирования. 2.3.2.
	
